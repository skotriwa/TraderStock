package com.intel.trader.Controller;
import com.intel.trader.History.History;
import com.intel.trader.administrator.Stock;
import com.intel.trader.limit.Limit;
import com.intel.trader.portfolio.Portfolio;
import com.intel.trader.repository.*;
import com.intel.trader.user.User;
import org.jboss.jandex.Main;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.awt.print.Pageable;
import java.time.*;
import java.time.temporal.ChronoField;
import java.util.*;
import java.lang.*;
import java.util.Collections;
import java.util.Optional;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;


@Controller // This means that this class is a Controller
@RequestMapping(path="/demo") // This means URL's start with /demo (after Application path)
public class MainController {
    History h = new History();
    public MainController(){
        Runnable priceRefresher = new Runnable(){
            @Override
            public void run() {
                refreshStockPrice();
            }
        };
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.scheduleAtFixedRate(priceRefresher, 15, 30, TimeUnit.SECONDS);

    }
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;
    @Autowired
    private StockRepository stockRepository;
    @Autowired
    private PortfolioRepository portfolioRepository;
    @Autowired
    private LimitRepository limitRepository;
    @Autowired
    private HistoryRepository historyRepository;
    @PostMapping(path="/addUser") // Map ONLY POST Requests
    public @ResponseBody String addNewUser (@RequestParam String name, @RequestParam String uname
            , @RequestParam String email) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        User n = new User();
        n.setFull_Name(name);
        n.setUser_Name(uname);
        n.setEmail(email);
        n.setUser_Type("Trader");
        n.setCashInAccount(0);
        userRepository.save(n);
        h.setUser_id(uname);
        h.setTxn_memo(uname+" was added");
        historyRepository.save(h);
        return "Saved";
    }
    //@RequestParam String name, @RequestParam String username, @RequestParam String email
    @PostMapping(path="/admin")
    public @ResponseBody String addAdmin(){
        User n = new User();
        n.setUser_Name("Admin");
        n.setFull_Name("Admin");
        n.setUser_Type("Admin");
        n.setEmail("Admin@stock.com");
        n.setCashInAccount(0);
        userRepository.save(n);
        return "Admin created";
    }
    @PostMapping(path = "/addInitialCash")
    public @ResponseBody String addCashToUser(@RequestParam String user_name, @RequestParam float cash){
        User u= userRepository.findAllById(Collections.singleton(user_name)).iterator().next();
        //userRepository.findById(user_name);
        u.setCashInAccount(cash);
        userRepository.save(u);
        h.setUser_id(user_name);
        h.setTxn_memo(cash + "was added");
        historyRepository.save(h);
        return "Stored to the user";
    }
    @PostMapping(path = "/buyStock")
    public @ResponseBody String addToPortfolio(@RequestParam String portfolio_sr, @RequestParam String user_name,@RequestParam String tic_name, @RequestParam int qty){
        //user has to enter porfolio_sr number if he/she owns a stock of that ticker
        Stock s=stockRepository.findAllById(Collections.singleton(tic_name)).iterator().next();
        if(canTradeThisTime()) {
            if (canTradeOnDate(LocalDate.now())) {
                if (s.getVolume() > qty) {
                    if (portfolioRepository.findAllById(Collections.singleton(portfolio_sr)).iterator().next() != null) {
                        Portfolio p = portfolioRepository.findAllById(Collections.singleton(portfolio_sr)).iterator().next();
                        User u = userRepository.findAllById(Collections.singleton(user_name)).iterator().next();
                        u.setCashInAccount(u.getCashInAccount() - qty * s.getCurrentPrice());
                        p.setPortfolioSr(portfolio_sr);
                        p.setUser_Name(user_name);
                        p.setTickerName(tic_name);
                        p.setQtyOwned(qty + p.getQtyOwned());
                        portfolioRepository.save(p);
                        s.setCurrentVolume(s.getCurrentVolume() - qty);
                        stockRepository.save(s);
                        userRepository.save(u);
                        h.setUser_id(user_name);
                        h.setTxn_memo("Bought " + qty + " stocks of " + tic_name);
                        historyRepository.save(h);

                        return "Added to portfolio";
                    } else {
                        Portfolio p = new Portfolio();
                        User u = userRepository.findAllById(Collections.singleton(user_name)).iterator().next();
                        u.setCashInAccount(u.getCashInAccount() - qty * s.getCurrentPrice());
                        p.setPortfolioSr(portfolio_sr);
                        p.setUser_Name(user_name);
                        p.setTickerName(tic_name);
                        p.setQtyOwned(qty);
                        portfolioRepository.save(p);
                        s.setCurrentVolume(s.getCurrentVolume() - qty);
                        stockRepository.save(s);
                        userRepository.save(u);
                        h.setUser_id(user_name);
                        h.setTxn_memo("Bought " + qty + " stocks of " + tic_name);
                        historyRepository.save(h);
                        return "Added to portfolio";
                    }
                } else {
                    h.setUser_id(user_name);
                    h.setTxn_memo("Transaction failed because stocks not available");
                    historyRepository.save(h);
                    return "Not enough volume available";
                }
            } else {
                return "It is a weekend";
            }
        }
        else{
            return "Please return between 9:00:00 AM and 5:00:00 PM";
            }
    }
    //sell stock

    @GetMapping(path="/getLimits")
    public @ResponseBody Iterable<Limit> getAllLimits() {
        // This returns a JSON or XML with the users
        return limitRepository.findAll();
    }

    @PostMapping(path="/addBuyLimit")
    public @ResponseBody String addBuyLimit(@RequestParam String user_name, @RequestParam String tic_name, @RequestParam float price_req, @RequestParam Date start, @RequestParam Date end){
        Limit l = new Limit();
        l.setEnd_Date(end);
        l.setStart_Date(start);
        l.setUser_name(user_name);
        l.setPrice(price_req);
        l.setTic_name(tic_name);
        l.setType("B");
        limitRepository.save(l);
        return "Limit information added to table";
    }

    @PostMapping(path="/removeBuyLimit")
    public @ResponseBody String removeBuyLimit(@RequestParam String limit_Id){
        limitRepository.deleteById(limit_Id);
        return  "Stock buy limit request successfully deleted";
    }

    @PostMapping(path="/addStock")
    public @ResponseBody String addStock(@RequestParam float price, @RequestParam String tic, @RequestParam String comp, @RequestParam int vol) {
        if (stockRepository.findAllById(Collections.singleton(tic)).iterator().next() != null) {
                Stock s= stockRepository.findAllById(Collections.singleton(tic)).iterator().next();
                s.setStockPrice(price);
                s.setVolume(s.getVolume()+vol);
                s.setCurrentPrice(price);
                s.setMarketCap(s.getVolume()*s.getCurrentPrice());
                stockRepository.save(s);
                return "Additional stocks updated to existing info";
        } else {
            Stock s = new Stock();
            s.setStockPrice(price);
            s.setTicker(tic);
            s.setCompany(comp);
            s.setVolume(vol);
            s.setCurrentPrice(price);
            s.setCurrentVolume(vol);
            s.setMarketCap(vol * s.getCurrentPrice());
            stockRepository.save(s);
            return "Stock created";
        }
    }
    @GetMapping(path="/all")
    public @ResponseBody Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }
    @GetMapping(path="/allStock")
    public @ResponseBody Iterable<Stock> getAllStocks() {
        // This returns a JSON or XML with the users
        return stockRepository.findAll();
    }
//    @GetMapping(path="/userHistory")
//    public @ResponseBody Iterable<History> getUserHistory(String user_name, Pageable pageable) {
//        // This returns a JSON or XML with the users
//        return historyRepository.findByUserIn(Arrays.asList(user_name), pageable);
//    }
    public void refreshStockPrice(){
        for (Stock s:stockRepository.findAll()){
            float factor= 1+((float)Math.random()-(float)0.5)/5;
            s.setCurrentPrice(s.getCurrentPrice()*factor);
            stockRepository.save(s);
        }
    }
    public boolean canTradeOnDate(final LocalDate ld){
        DayOfWeek day = DayOfWeek.of(ld.get(ChronoField.DAY_OF_WEEK));
        return day == DayOfWeek.SUNDAY || day == DayOfWeek.SATURDAY;
    }

    public boolean canTradeThisTime(){
        LocalTime start = LocalTime.parse( "09:00:00" );
        LocalTime stop = LocalTime.parse( "17:00:00" );
        LocalTime target = LocalTime.now();
        return ( target.isAfter( start ) && target.isBefore( stop ) ) ;
    }
}
